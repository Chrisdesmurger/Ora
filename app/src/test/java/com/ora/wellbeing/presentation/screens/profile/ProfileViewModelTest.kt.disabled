package com.ora.wellbeing.presentation.screens.profile

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import app.cash.turbine.test
import com.google.common.truth.Truth.assertThat
import com.ora.wellbeing.data.model.PlanTier
import com.ora.wellbeing.data.model.UserProfile as DataUserProfile
import com.ora.wellbeing.data.model.UserStats as DataUserStats
import com.ora.wellbeing.data.repository.UserProfileRepository
import com.ora.wellbeing.data.repository.UserStatsRepository
import com.ora.wellbeing.data.sync.SyncManager
import com.ora.wellbeing.data.sync.SyncState
import io.mockk.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.test.*
import org.junit.After
import org.junit.Before
import org.junit.Ignore
import org.junit.Rule
import org.junit.Test

/**
 * FIX(user-dynamic): Tests unitaires pour ProfileViewModel
 *
 * Couverture:
 * - Chargement initial des données
 * - États de chargement (loading, success, error)
 * - Transformation données Firestore -> UiState
 * - Gestion des erreurs
 * - Toggle goals
 * - Update motto et photoUrl
 *
 * Stack: JUnit 4, MockK, Coroutines Test, Turbine, Truth
 */
@Ignore("TODO: Fix domain model refactoring + JVM target issues - tracked in separate issue")
@OptIn(ExperimentalCoroutinesApi::class)
class ProfileViewModelTest {

    // FIX(user-dynamic): Rule pour LiveData synchrone dans les tests
    @get:Rule
    val instantTaskExecutorRule = InstantTaskExecutorRule()

    // Test dispatcher pour coroutines
    private val testDispatcher = StandardTestDispatcher()

    // Mocks
    private lateinit var syncManager: SyncManager
    private lateinit var userProfileRepository: UserProfileRepository
    private lateinit var userStatsRepository: UserStatsRepository

    // Flows mockés depuis SyncManager
    private val userProfileFlow = MutableStateFlow<DataUserProfile?>(null)
    private val userStatsFlow = MutableStateFlow<DataUserStats?>(null)
    private val syncStateFlow = MutableStateFlow<SyncState>(SyncState.Idle)

    // ViewModel sous test
    private lateinit var viewModel: ProfileViewModel

    private val testUid = "test-user-123"

    @Before
    fun setup() {
        // FIX(user-dynamic): Configurer dispatcher de test
        Dispatchers.setMain(testDispatcher)

        // Créer les mocks
        syncManager = mockk(relaxed = true)
        userProfileRepository = mockk(relaxed = true)
        userStatsRepository = mockk(relaxed = true)

        // FIX(user-dynamic): Stub les flows du SyncManager
        every { syncManager.userProfile } returns userProfileFlow
        every { syncManager.userStats } returns userStatsFlow
        every { syncManager.syncState } returns syncStateFlow

        // Créer le ViewModel (init{} va s'abonner aux flows)
        viewModel = ProfileViewModel(
            syncManager = syncManager,
            userProfileRepository = userProfileRepository,
            userStatsRepository = userStatsRepository
        )

        // Avancer dispatcher pour exécuter init{}
        testDispatcher.scheduler.advanceUntilIdle()
    }

    @After
    fun tearDown() {
        // FIX(user-dynamic): Restaurer dispatcher principal
        Dispatchers.resetMain()
        clearAllMocks()
    }

    // ============================================
    // Tests d'état initial
    // ============================================

    @Test
    fun `uiState initial state is empty`() = runTest {
        // FIX(user-dynamic): État initial avant chargement des données
        val initialState = viewModel.uiState.value

        assertThat(initialState.isLoading).isFalse()
        assertThat(initialState.error).isNull()
        assertThat(initialState.userProfile).isNull()
        assertThat(initialState.practiceTimes).isEmpty()
        assertThat(initialState.streak).isEqualTo(0)
        assertThat(initialState.totalTime).isEmpty()
        assertThat(initialState.goals).isEmpty()
    }

    // ============================================
    // Tests de chargement de profil
    // ============================================

    @Test
    fun `observeUserData updates uiState when profile loaded`() = runTest {
        // FIX(user-dynamic): Profil chargé depuis Firestore via SyncManager
        val mockProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            photoUrl = null,
            planTier = PlanTier.FREE,
            motto = "Je prends soin de moi",
            createdAt = System.currentTimeMillis()
        )

        viewModel.uiState.test {
            // État initial
            val initial = awaitItem()
            assertThat(initial.userProfile).isNull()

            // Émettre un profil
            userProfileFlow.value = mockProfile
            testDispatcher.scheduler.advanceUntilIdle()

            // État mis à jour
            val updated = awaitItem()
            assertThat(updated.userProfile).isNotNull()
            assertThat(updated.userProfile?.name).isEqualTo("Clara")
            assertThat(updated.userProfile?.motto).isEqualTo("Je prends soin de moi")
            assertThat(updated.userProfile?.isPremium).isFalse()
        }
    }

    @Test
    fun `observeUserData updates stats correctly`() = runTest {
        // FIX(user-dynamic): Stats chargées depuis Firestore
        val mockStats = DataUserStats(
            uid = testUid,
            totalMinutes = 120,
            totalSessions = 5,
            currentStreak = 3,
            longestStreak = 7,
            lastPracticeAt = System.currentTimeMillis(),
            hasGratitudeToday = true,
            activeGoals = listOf("goal_read", "goal_exercise"),
            completedGoals = listOf("goal_alcohol")
        )

        viewModel.uiState.test {
            // État initial
            awaitItem()

            // Émettre des stats
            userStatsFlow.value = mockStats
            testDispatcher.scheduler.advanceUntilIdle()

            // État mis à jour
            val updated = awaitItem()
            assertThat(updated.streak).isEqualTo(3)
            assertThat(updated.hasGratitudeToday).isTrue()
            assertThat(updated.totalTime).isNotEmpty()
            assertThat(updated.goals).isNotEmpty()
        }
    }

    @Test
    fun `observeUserData shows loading state during sync`() = runTest {
        // FIX(user-dynamic): État loading pendant la sync
        viewModel.uiState.test {
            // État initial
            awaitItem()

            // Déclencher état Syncing
            syncStateFlow.value = SyncState.Syncing
            testDispatcher.scheduler.advanceUntilIdle()

            // Vérifier état loading
            val loading = awaitItem()
            assertThat(loading.isLoading).isTrue()
            assertThat(loading.error).isNull()
        }
    }

    @Test
    fun `observeUserData shows error when sync fails`() = runTest {
        // FIX(user-dynamic): Gestion d'erreur de sync
        val errorMessage = "Erreur réseau"

        viewModel.uiState.test {
            // État initial
            awaitItem()

            // Déclencher état Error
            syncStateFlow.value = SyncState.Error(errorMessage)
            testDispatcher.scheduler.advanceUntilIdle()

            // Vérifier état error
            val error = awaitItem()
            assertThat(error.isLoading).isFalse()
            assertThat(error.error).isEqualTo(errorMessage)
        }
    }

    @Test
    fun `observeUserData handles null profile gracefully`() = runTest {
        // FIX(user-dynamic): Profil null (user non connecté)
        viewModel.uiState.test {
            // État initial
            val initial = awaitItem()
            assertThat(initial.userProfile).isNull()

            // Émettre null explicitement
            userProfileFlow.value = null
            testDispatcher.scheduler.advanceUntilIdle()

            // Pas de crash, état reste cohérent
            val updated = awaitItem()
            assertThat(updated.userProfile).isNull()
            assertThat(updated.error).isNull()
        }
    }

    // ============================================
    // Tests de premium status
    // ============================================

    @Test
    fun `profile shows isPremium true for premium tier`() = runTest {
        // FIX(user-dynamic): Détection premium
        val premiumProfile = DataUserProfile(
            uid = testUid,
            firstName = "Jean",
            planTier = PlanTier.PREMIUM,
            createdAt = System.currentTimeMillis()
        )

        viewModel.uiState.test {
            awaitItem()

            userProfileFlow.value = premiumProfile
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.userProfile?.isPremium).isTrue()
            assertThat(updated.userProfile?.planTier).contains("premium")
        }
    }

    @Test
    fun `profile shows isPremium false for free tier`() = runTest {
        // FIX(user-dynamic): Détection free
        val freeProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        viewModel.uiState.test {
            awaitItem()

            userProfileFlow.value = freeProfile
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.userProfile?.isPremium).isFalse()
        }
    }

    // ============================================
    // Tests de displayName
    // ============================================

    @Test
    fun `profile displayName uses firstName when available`() = runTest {
        // FIX(user-dynamic): Affichage du nom
        val profile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        viewModel.uiState.test {
            awaitItem()

            userProfileFlow.value = profile
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.userProfile?.name).isEqualTo("Clara")
        }
    }

    @Test
    fun `profile displayName shows Invité when firstName is null`() = runTest {
        // FIX(user-dynamic): Utilisateur anonyme
        val anonymousProfile = DataUserProfile(
            uid = testUid,
            firstName = null,
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        viewModel.uiState.test {
            awaitItem()

            userProfileFlow.value = anonymousProfile
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.userProfile?.name).isEqualTo("Invité")
        }
    }

    // ============================================
    // Tests de toggle goal
    // ============================================

    @Test
    fun `toggleGoal updates goal state optimistically`() = runTest {
        // FIX(user-dynamic): Update optimiste avant Firestore
        val mockProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        val mockStats = DataUserStats(
            uid = testUid,
            activeGoals = listOf("goal_read"),
            completedGoals = emptyList()
        )

        userProfileFlow.value = mockProfile
        userStatsFlow.value = mockStats
        testDispatcher.scheduler.advanceUntilIdle()

        // Mock repository response
        coEvery { userStatsRepository.completeGoal(testUid, "goal_read") } returns Result.success(Unit)

        // Toggle goal
        viewModel.onEvent(ProfileUiEvent.ToggleGoal("goal_read"))
        testDispatcher.scheduler.advanceUntilIdle()

        // Vérifier appel repository
        coVerify { userStatsRepository.completeGoal(testUid, "goal_read") }
    }

    @Test
    fun `toggleGoal handles error gracefully`() = runTest {
        // FIX(user-dynamic): Gestion d'erreur lors du toggle
        val mockProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        userProfileFlow.value = mockProfile
        testDispatcher.scheduler.advanceUntilIdle()

        // Mock repository failure
        coEvery { userStatsRepository.completeGoal(any(), any()) } returns Result.failure(Exception("Network error"))

        viewModel.uiState.test {
            awaitItem() // État initial

            viewModel.onEvent(ProfileUiEvent.ToggleGoal("goal_read"))
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.error).isNotNull()
            assertThat(updated.error).contains("Erreur")
        }
    }

    // ============================================
    // Tests de update motto
    // ============================================

    @Test
    fun `updateMotto calls repository with correct parameters`() = runTest {
        // FIX(user-dynamic): Mise à jour du motto
        val mockProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        userProfileFlow.value = mockProfile
        testDispatcher.scheduler.advanceUntilIdle()

        coEvery { userProfileRepository.updateMotto(testUid, any()) } returns Result.success(Unit)

        val newMotto = "Nouveau motto inspirant"
        viewModel.onEvent(ProfileUiEvent.UpdateMotto(newMotto))
        testDispatcher.scheduler.advanceUntilIdle()

        // Vérifier appel
        coVerify { userProfileRepository.updateMotto(testUid, newMotto) }
    }

    @Test
    fun `updateMotto handles error`() = runTest {
        // FIX(user-dynamic): Erreur lors update motto
        val mockProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        userProfileFlow.value = mockProfile
        testDispatcher.scheduler.advanceUntilIdle()

        coEvery { userProfileRepository.updateMotto(any(), any()) } returns Result.failure(Exception("Firestore error"))

        viewModel.uiState.test {
            awaitItem()

            viewModel.onEvent(ProfileUiEvent.UpdateMotto("Test"))
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.error).contains("motto")
        }
    }

    // ============================================
    // Tests de update photoUrl
    // ============================================

    @Test
    fun `updatePhotoUrl calls repository correctly`() = runTest {
        // FIX(user-dynamic): Mise à jour de la photo
        val mockProfile = DataUserProfile(
            uid = testUid,
            firstName = "Clara",
            planTier = PlanTier.FREE,
            createdAt = System.currentTimeMillis()
        )

        userProfileFlow.value = mockProfile
        testDispatcher.scheduler.advanceUntilIdle()

        coEvery { userProfileRepository.updatePhotoUrl(testUid, any()) } returns Result.success(Unit)

        val newPhotoUrl = "https://example.com/new-photo.jpg"
        viewModel.onEvent(ProfileUiEvent.UpdatePhotoUrl(newPhotoUrl))
        testDispatcher.scheduler.advanceUntilIdle()

        coVerify { userProfileRepository.updatePhotoUrl(testUid, newPhotoUrl) }
    }

    // ============================================
    // Tests de practice times
    // ============================================

    @Test
    fun `practiceTimes are built from stats`() = runTest {
        // FIX(user-dynamic): Construction des temps de pratique
        val mockStats = DataUserStats(
            uid = testUid,
            totalMinutes = 240,
            yogaMinutes = 60,
            pilatesMinutes = 40,
            meditationMinutes = 100,
            breathingMinutes = 40
        )

        viewModel.uiState.test {
            awaitItem()

            userStatsFlow.value = mockStats
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.practiceTimes).hasSize(4)

            val yoga = updated.practiceTimes.find { it.id == "yoga" }
            assertThat(yoga).isNotNull()
            assertThat(yoga?.name).isEqualTo("Yoga")
            assertThat(yoga?.time).contains("1h")
        }
    }

    // ============================================
    // Tests de goals
    // ============================================

    @Test
    fun `goals are built from activeGoals and completedGoals`() = runTest {
        // FIX(user-dynamic): Construction des objectifs
        val mockStats = DataUserStats(
            uid = testUid,
            activeGoals = listOf("goal_read", "goal_exercise"),
            completedGoals = listOf("goal_alcohol")
        )

        viewModel.uiState.test {
            awaitItem()

            userStatsFlow.value = mockStats
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.goals).isNotEmpty()

            val completedGoal = updated.goals.find { it.id == "goal_alcohol" }
            assertThat(completedGoal?.isCompleted).isTrue()

            val activeGoal = updated.goals.find { it.id == "goal_read" }
            assertThat(activeGoal?.isCompleted).isFalse()
        }
    }

    @Test
    fun `goals list is limited to 5 items`() = runTest {
        // FIX(user-dynamic): Limite de 5 objectifs affichés
        val mockStats = DataUserStats(
            uid = testUid,
            activeGoals = listOf("goal_1", "goal_2", "goal_3", "goal_4"),
            completedGoals = listOf("goal_5", "goal_6", "goal_7")
        )

        viewModel.uiState.test {
            awaitItem()

            userStatsFlow.value = mockStats
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.goals).hasSize(5)
        }
    }

    // ============================================
    // Tests de streak
    // ============================================

    @Test
    fun `streak is displayed from stats`() = runTest {
        // FIX(user-dynamic): Affichage du streak
        val mockStats = DataUserStats(
            uid = testUid,
            currentStreak = 7,
            longestStreak = 15
        )

        viewModel.uiState.test {
            awaitItem()

            userStatsFlow.value = mockStats
            testDispatcher.scheduler.advanceUntilIdle()

            val updated = awaitItem()
            assertThat(updated.streak).isEqualTo(7)
        }
    }

    // ============================================
    // Tests de navigation events
    // ============================================

    @Test
    fun `NavigateToEditProfile event is logged`() = runTest {
        // FIX(user-dynamic): Navigation gérée par le Screen
        viewModel.onEvent(ProfileUiEvent.NavigateToEditProfile)
        testDispatcher.scheduler.advanceUntilIdle()

        // Pas de crash, juste log (vérifié par Timber en vrai)
        assertThat(viewModel.uiState.value.error).isNull()
    }

    @Test
    fun `NavigateToPracticeStats event is logged`() = runTest {
        // FIX(user-dynamic): Navigation vers stats de pratique
        viewModel.onEvent(ProfileUiEvent.NavigateToPracticeStats("yoga"))
        testDispatcher.scheduler.advanceUntilIdle()

        assertThat(viewModel.uiState.value.error).isNull()
    }

    @Test
    fun `NavigateToGratitudes event is logged`() = runTest {
        // FIX(user-dynamic): Navigation vers gratitudes
        viewModel.onEvent(ProfileUiEvent.NavigateToGratitudes)
        testDispatcher.scheduler.advanceUntilIdle()

        assertThat(viewModel.uiState.value.error).isNull()
    }
}
