rules_version = '2';

// FIX(user-dynamic): Règles de sécurité Firestore pour Ora
// Privacy by design: Chaque utilisateur peut uniquement accéder à ses propres données
// Basé sur user_data_contract.yaml

service cloud.firestore {
  match /databases/{database}/documents {

    // Collection users/{uid}
    // Règle: Lecture/écriture uniquement si request.auth.uid == uid
    match /users/{uid} {
      // Permet lecture et écriture uniquement si authentifié et c'est son propre document
      allow read, write: if request.auth != null && request.auth.uid == uid;

      // Validation des champs à l'écriture
      allow create: if request.auth != null
                    && request.auth.uid == uid
                    && validateUserProfile(request.resource.data);

      allow update: if request.auth != null
                    && request.auth.uid == uid
                    && validateUserProfile(request.resource.data);
    }

    // Collection stats/{uid}
    // Règle: Lecture/écriture uniquement si request.auth.uid == uid
    match /stats/{uid} {
      // Permet lecture et écriture uniquement si authentifié et c'est son propre document
      allow read, write: if request.auth != null && request.auth.uid == uid;

      // Validation des champs à l'écriture
      allow create: if request.auth != null
                    && request.auth.uid == uid
                    && validateUserStats(request.resource.data);

      allow update: if request.auth != null
                    && request.auth.uid == uid
                    && validateUserStats(request.resource.data);
    }

    // Collection gratitudes/{uid}/entries/{date}
    // Règle: UID-based isolation - chaque utilisateur accède uniquement à ses propres entrées
    match /gratitudes/{uid}/entries/{date} {
      allow read, write: if request.auth != null && request.auth.uid == uid;

      // Validation des champs à l'écriture
      allow create: if request.auth != null
                    && request.auth.uid == uid
                    && validateGratitudeEntry(request.resource.data);

      allow update: if request.auth != null
                    && request.auth.uid == uid
                    && validateGratitudeEntry(request.resource.data);
    }

    // Collection programs/{programId}
    // Règle: Lecture pour tous les utilisateurs authentifiés, écriture admin uniquement
    match /programs/{programId} {
      allow read: if request.auth != null;
      allow write: if false; // Admin only (future Cloud Functions)
    }

    // Collection user_programs/{uid}/enrolled/{programId}
    // Règle: UID-based isolation - chaque utilisateur accède uniquement à ses propres programmes inscrits
    match /user_programs/{uid}/enrolled/{programId} {
      allow read, write: if request.auth != null && request.auth.uid == uid;

      // Validation des champs à l'écriture
      allow create: if request.auth != null
                    && request.auth.uid == uid
                    && validateUserProgram(request.resource.data);

      allow update: if request.auth != null
                    && request.auth.uid == uid
                    && validateUserProgram(request.resource.data);
    }

    // Collection content/{contentId}
    // Règle: Lecture pour tous les utilisateurs authentifiés, écriture admin uniquement
    match /content/{contentId} {
      allow read: if request.auth != null;
      allow write: if false; // Admin only (future Cloud Functions)
    }

    // Fonctions de validation

    // Valide les données du profil utilisateur
    function validateUserProfile(data) {
      return data.uid is string
          && data.uid.size() > 0
          && (data.firstName == null || (data.firstName is string && data.firstName.size() <= 50))
          && (data.photoUrl == null || data.photoUrl is string)
          && data.planTier in ['free', 'premium']
          && data.createdAt is timestamp
          && (data.locale == null || data.locale in ['fr', 'en'])
          && (data.updatedAt == null || data.updatedAt is timestamp);
    }

    // Valide les statistiques utilisateur
    function validateUserStats(data) {
      return data.uid is string
          && data.uid.size() > 0
          && data.totalMinutes is int
          && data.totalMinutes >= 0
          && data.totalMinutes <= 525600  // Max 1 an de minutes
          && data.totalSessions is int
          && data.totalSessions >= 0
          && data.currentStreak is int
          && data.currentStreak >= 0
          && data.currentStreak <= 3650  // Max 10 ans
          && (data.lastPracticeAt == null || data.lastPracticeAt is timestamp)
          && data.createdAt is timestamp
          && data.updatedAt is timestamp;
    }

    // Valide une entrée de gratitude
    function validateGratitudeEntry(data) {
      return data.uid is string
          && data.uid.size() > 0
          && data.date is string
          && data.date.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$')  // Format YYYY-MM-DD
          && data.gratitudes is list
          && data.gratitudes.size() >= 1
          && data.gratitudes.size() <= 3
          && (data.notes == null || (data.notes is string && data.notes.size() <= 500))
          && data.createdAt is timestamp
          && (data.updatedAt == null || data.updatedAt is timestamp);
    }

    // Valide un programme utilisateur
    function validateUserProgram(data) {
      return data.uid is string
          && data.uid.size() > 0
          && data.programId is string
          && data.programId.size() > 0
          && data.currentDay is int
          && data.currentDay >= 0
          && data.totalDays is int
          && data.totalDays > 0
          && data.currentDay <= data.totalDays
          && data.isCompleted is bool
          && data.startedAt is timestamp
          && (data.lastSessionAt == null || data.lastSessionAt is timestamp)
          && (data.completedAt == null || data.completedAt is timestamp);
    }

    // Bloquer tout accès aux autres collections par défaut
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
